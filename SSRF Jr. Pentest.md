# SSRF Jr. Pentest




-----
What is SSRF (Server-Side Request Forgery)?

SSRF (Server-Side Request Forgery) is a type of security vulnerability that allows an attacker to make the server perform requests to unintended locations, internal services, or external domains. The server acts as a proxy, which can be exploited to bypass network restrictions, access sensitive data, or interact with services that would otherwise be inaccessible to the attacker.

How SSRF Works:

When a web application receives a URL or other input that it then uses to make server-side requests, SSRF exploits occur if the attacker can control this request input. The server, acting on behalf of the attacker, may access internal or external services, leading to possible unauthorized access to sensitive information.


---

Examples of SSRF:

1. Basic SSRF Example: Consider a web application that fetches remote content through a URL parameter:

http://example.com/fetch?url=http://target.com/data

An attacker can manipulate this:

http://example.com/fetch?url=http://localhost/admin

Here, the attacker tricks the server into making a request to an internal network resource like http://localhost/admin, which may return sensitive data.


2. SSRF to Access Metadata (Cloud): In cloud environments (e.g., AWS), services like EC2 often provide metadata endpoints at 169.254.169.254. If an attacker can control the URL input:

http://example.com/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials

The attacker could retrieve sensitive metadata, including access tokens, IAM roles, and other configurations.


3. SSRF in Internal Network Scanning: By manipulating the server's request, an attacker can make the server access various IPs and ports within the internal network:

http://example.com/fetch?url=http://10.0.0.1:80
http://example.com/fetch?url=http://10.0.0.1:22

This technique can be used to identify open ports and services running inside the network.




---

Finding SSRF Vulnerabilities:

1. User-Supplied URL Parameters: Check web applications that accept user inputs for URLs, such as:

URL preview generators

Image/file upload services that fetch external resources

APIs that make server-to-server requests



2. Localhost and Internal IPs: Test if the server can access internal resources by trying URLs like:

http://127.0.0.1

http://169.254.169.254 (for cloud metadata services)

Internal subnets like 10.0.0.x or 192.168.x.x



3. Port Scanning via SSRF: Use different IP:port combinations to probe the server’s internal network to identify services like databases, administrative interfaces, or cloud services.


4. Bypass URL Validation: Sometimes, applications attempt to filter URLs by checking if they point to internal IP addresses or certain protocols. Bypass methods include:

DNS rebinding (using domain names that resolve to internal IPs)

Malformed URLs (http://localhost%00.example.com)

Using HTTP redirection to bypass initial URL filters





---

Common SSRF Defenses:

1. URL Whitelisting: Only allow the server to request URLs from a predefined list of trusted domains.

Weakness: Can be bypassed if the whitelist isn’t strict or if DNS manipulation (e.g., DNS rebinding) occurs.



2. URL Blacklisting: Block known dangerous endpoints like 127.0.0.1, 169.254.169.254, and internal network ranges.

Weakness: Blacklists can be bypassed using different notations ([::1] for IPv6 localhost) or encoded URLs.



3. Validating the Host Header: Ensure that the domain being fetched matches the expected domain.

Weakness: DNS rebinding or redirect chains can still allow access to internal services.



4. Firewalls & Network Segmentation: Restrict internal services so that only trusted IPs can access them, limiting the server’s ability to reach sensitive internal systems.

Weakness: This requires tight configuration, and some services (like cloud metadata APIs) may be more challenging to restrict.



5. Disable Unnecessary Internal Services: Reduce the attack surface by disabling services that aren’t required (e.g., cloud metadata services or unnecessary admin panels).




---

Defeating SSRF Defenses:

1. Bypassing Whitelisting:

DNS Rebinding: In this attack, the domain initially resolves to a public IP, but after the connection is established, the DNS resolution changes to an internal IP.

Redirect Chains: Use a URL that redirects the server to an internal IP (e.g., http://trusted.com -> http://internal.com).



2. Exploiting IP Address Representations:

Use different encodings like hexadecimal, octal, or even mixed encodings to bypass basic filters. Example: http://2130706433 instead of http://127.0.0.1.



3. Bypassing Host Header Validation:

Modify request headers to bypass validation, or use alternate protocols like gopher:// or ftp://, depending on what the server supports.



4. Advanced Techniques:

Smuggling Payloads via Out-of-Band (OOB) Channels: If the target server can interact with external domains, use SSRF to leak information to an external server you control (e.g., over DNS or HTTP).

SSRF in Webhooks: Webhooks, which send HTTP requests between services, are often vulnerable to SSRF, especially when they accept user input and make server-to-server requests.





---

Summary:

SSRF is a powerful attack that can be used to exploit server functionality and access sensitive internal services or information. By understanding how servers process requests, an attacker can leverage SSRF to gain deeper network access or leak data.

To defend against SSRF, developers should:

Strictly validate and sanitize user inputs.

Apply least privilege network access control.

Avoid fetching data based on user-controlled input unless absolutely necessary.
